# 操作系统

**进程线程区别**

进程：进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中**分配和管理资源的基本单位**，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态

线程：线程是**CPU调度和分派的基本单位**，它可与同属一个进程的其他的线程共享进程所拥有的全部资源

### 进程间通讯方式

------

**传统通信方式**

1. 无名管道 pipe（管道：把一个程序的输出直接连接到另一个程序的输入）

   * 只能用于父子或兄弟之间

   * 单工，存在固定的输出端和输入端

   * 可以被看成是特殊的文件，用文件操作方式进行操作，但是只存在于内存中，不存在文件系统中

     <img src="/Users/a1466055840/Library/Application Support/typora-user-images/image-20210224151928688.png" alt="image-20210224151928688" style="zoom:50%;" />

     pipe会创建**两个文件描述符，这两个文件描述符指向同一个文件pipe**，0和标准输入一样用于写，1和标准输出一样用于读。

     父子进程都有输入和输出文件描述符，但是只能使用其中一个

     

2. 有名管道 fifo

   * 一样是单工，存在固定的输入端和输出端
   * 它可以使**互不相关**的两个进程实现彼此通信
   * 该管道可以**通过路径名来指出**，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便
   * fifo严格遵守先进先出的原则
   * 堆内存的管理使用阻塞，满了阻塞写，空了阻塞读

3. 信号 signal

   **大佬的文档：**https://www.cnblogs.com/sky-heaven/p/10176422.html

   这里介绍几个常用的信号

   | 信号名   | 含义                                                         | 默认操作 |
   | -------- | ------------------------------------------------------------ | -------- |
   | SIGINT   | 该信号在用户输入INTR字符（通常是Ctrl + C）时发出， 终端驱动程序发送该信号并送到前台进程中的每一个进程 | 终止进程 |
   | SIGQUIT  | 该信号和SIGINT类似，但由QUIT字符（通常是Ctrl + \）来 控制    | 终止进程 |
   | SIGKILL  | 该信号用来立即结束程序的运行； 不能被阻塞、处理和忽略；      | 终止进程 |
   | SIGALARM | 该信号当一个定时器到时的时候发出；                           | 终止进程 |
   | SIGSTOP  | 该信号用于暂停一个进程； 不能被阻塞、处理和忽略；            | 暂停进程 |
   | SIGTSTP  | 该信号用于交互停止进程（挂起），由Ctrl + Z 来发出            | 终止进程 |

   <img src="/Users/a1466055840/Library/Application Support/typora-user-images/image-20210224155952639.png" alt="image-20210224155952639" style="zoom:50%;" />

   

   

   ------

   **IPC对象**

   * 一种类似于文件的**用于进程间通讯的对象**
   * 活动在**内核级别**，所以单个进程使用它也要使用**标识符**来访问
   * 为了使多个进程共享一个IPC（因为各个进程标识符不一样），要设置一个“**键**”
   * 可以把键存在文件里，然后读文件，也可以设置一个多进程都知道的键
   * IPC和文件系统不是通用的，所以操作很麻烦，要单独的接口
   * 对IPC对象的控制都是单独的操作函数
   * IPC不能自动资源回收

   1. 共享内存 shared memory

      * 使用**虚拟内存**来为进程分配内存，不同**虚拟内存**映射到同一块**物理内存**上，同时使用分页机制保障各个进程有自己的独立空间，从而完成共享内存

      * 共享内存**可以通过系统调用**创建，返回IPC标识符
      * 如果一个进程想要使用一个共享内存，**它要将此内存区附加到它的地址空间，也可以通过系统调用实现**

   2. 信号量 semaphore

      这个都熟悉

      事实上，在信号量的实际应用中，是不能单独定义一个信号量的，而只能定义**一个信号量集**，其中包含**一组信号量，同一信号量集中的信号量使用同一个引用ID**，这样的设置是为了多个资源和同步操作的需要

      对信号量的操作：

      ![image-20210224165414334](/Users/a1466055840/Library/Application Support/typora-user-images/image-20210224165414334.png)

      sembuf是对信号灯进行的操作流，semop为原子操作，必须全部执行完成

      ```c
      struct sembuf
      {
      	unsigned short sem_num; //要操作的信号灯的编号
      	short sem_op;   //  0: 等待，知道信号灯的值变为0
                              //  1: 释放资源，V操作 
                              // -1: 分配资源，P操作
      	short sem_flg; //0，IPC_NOWAIT,SEM_UNDO
      }
      ```

      

   3. 消息队列 message queue



### 死锁死个条件

1. 互斥
2. 不可抢占
3. 循环等待
4. 占有且等待

如何避免死锁



